└── backend
    ├── config/restaurant.php
    ├── app/Http/Controllers/BookingController.php
    ├── app/Http/Controllers/Controller.php
    ├── app/Http/Controllers/TableAvailabilityController.php
    ├── app/Http/Controllers/OpenDayController.php
    ├── app/Http/Controllers/ClosedDayController.php
    ├── app/Http/Controllers/SystemSettingController.php
    ├── app/Http/Resources/BookingDetailResource.php
    ├── app/Http/Resources/BookingResource.php
    ├── app/Http/Resources/TableAvailabilityResource.php
    ├── app/Http/Kernel.php
    ├── app/Mail/BookingConfirmationMail.php
    ├── app/Mail/BookingFeedbackMail.php
    ├── app/Mail/BookingReminderMail.php
    ├── app/Models/Booking.php
    ├── app/Models/BookingDetail.php
    ├── app/Models/TableAvailability.php
    ├── app/Models/User.php
    ├── app/Models/ClosedDay.php
    ├── app/Models/OpenDay.php
    ├── app/Models/SystemSetting.php
    ├── app/Services/BookingAlgorithmService.php
    ├── app/Services/CalendarService.php
    ├── database/migrations/2025_02_03_191203_create_table_availabilities_table.php
    ├── database/migrations/2025_02_04_115733_create_bookings_table.php
    ├── database/migrations/2025_02_26_163537_create_booking_details_table.php
    ├── database/migrations/2025_02_27_174815_create_jobs_table.php
    ├── database/migrations/2025_04_20_143322_add_long_stay_to_bookings_table.php
    ├── database/migrations/2025_05_04_155326_create_closed_days_table.php
    ├── database/migrations/2025_05_04_155330_create_system_settings_table.php
    ├── database/migrations/2025_05_04_182837_create_calendar_overrides_table.php
    ├── database/migrations/2025_05_04_184511_create_open_days_table.php
    ├── database/seeders/BookingSeeder.php
    ├── database/seeders/DatabaseSeeder.php
    ├── database/seeders/TableAvailabilitySeeder.php
    ├── routes/api.php
    ├── config/mail.php
    ├── config/restaurant.php
    ├── config/restaurant_dataset.php

––––––––––––––––––––––––
backend/config/restaurant.php
    <?php
    /**
     * Restaurant-level operational parameters
     * (single source of truth for the algorithm).
     *
     */
    
    return [
    
        /*───────────────────────────────────────────────────────────
         | Seating rounds – start / end for every service window
         *───────────────────────────────────────────────────────────*/
        'rounds' => [
            'lunch' => [
                'first_round'  => [
                    'start' => '13:00',
                    'end'   => '14:59',
                    'note'  => '1st lunch',
                ],
                'second_round' => [
                    'start' => '15:00',
                    'end'   => '17:30',
                    'note'  => '2nd lunch',
                ],
            ],
            'dinner' => [
                'dinner_round' => [
                    'start' => '20:00',
                    'end'   => '23:30',
                    'note'  => 'Dinner',
                ],
            ],
        ],
    
        /*───────────────────────────────────────────────────────────
         | Party-size slack ϵ   ( capacity ≥ party − ϵ )
         *───────────────────────────────────────────────────────────*/
        'party_to_eps' => [
            1 => 0,
            2 => 3,
            3 => 2,
            4 => 1,
        ],
    
        /*───────────────────────────────────────────────────────────
         | Slot granularity – minutes between successive booking slots
         *───────────────────────────────────────────────────────────*/
        'slot_step'    => 15,
    
        /*───────────────────────────────────────────────────────────
         | Physical table sizes available
         *───────────────────────────────────────────────────────────*/
        'capacities'   => [2, 4, 6],
    
        /*───────────────────────────────────────────────────────────
         | ZONE THRESHOLDS φ1..φ4 (five-zone policy)
         | Hard-coded values; widget will never re-derive these.
         *───────────────────────────────────────────────────────────*/
        'phi' => [
            'phi1' => 0.401,
            'phi2' => 0.547,
            'phi3' => 0.714,
            'phi4' => 0.800,
        ],
    
        /*───────────────────────────────────────────────────────────
         | Session parameters
         *───────────────────────────────────────────────────────────*/
        'tau'           => 1.75,    // hours incl. cleaning
        'omega'         => 1.50,    // long-stay multiplier
        'p_max'         => 14,      // largest party bookable online
        'beta'          => 0.05,    // walk-in buffer 5%
        'eta_max'       => 0.10,    // total invisible seats ≤10%
        'rebuild_times' => ['11:00', '17:00'], // daily shuffle
    ];

––––––––––––––––––––––––
backend/app/Http/Controllers/BookingController.php
    <?php
    
    namespace App\Http\Controllers;
    
    use App\Models\Booking;
    use App\Models\BookingDetail;
    use App\Models\TableAvailability;
    use App\Models\ClosedDay;
    use App\Models\SystemSetting;
    use App\Models\MealOverride;                          // ← NEW
    use Illuminate\Http\Request;
    use Illuminate\Support\Facades\DB;
    use Illuminate\Support\Facades\Mail;
    use App\Mail\BookingConfirmationMail;
    use App\Mail\BookingReminderMail;
    use App\Mail\BookingFeedbackMail;
    use Carbon\Carbon;
    use App\Services\BookingAlgorithmService;
    
    class BookingController extends Controller
    {
        /*───────────────────────────────────────────────────────────
          List all bookings (admin)
        ───────────────────────────────────────────────────────────*/
        public function index()
        {
            $bookings = Booking::with('tableAvailability', 'details')
                ->orderBy('created_at', 'desc')
                ->get();
    
            return response()->json(['data' => $bookings]);
        }
    
        /*───────────────────────────────────────────────────────────
          Create a new booking (public / admin)
        ───────────────────────────────────────────────────────────*/
        public function store(Request $request)
        {
            $validated = $request->validate([
                'date'             => 'required|date_format:Y-m-d',
                'meal_type'        => 'required|in:lunch,dinner',
                'reserved_time'    => 'required|date_format:H:i:s',
                'total_adults'     => 'required|integer|min:1',
                'total_kids'       => 'required|integer|min:0',
                'full_name'        => 'required|string',
                'phone'            => 'nullable|string',
                'email'            => 'nullable|email',
                'special_requests' => 'nullable|string',
                'gdpr_consent'     => 'boolean',
                'marketing_opt_in' => 'boolean',
                'long_stay'        => 'boolean',
            ]);
    
            /* ❌ booking-window not yet open */
            $openFrom = SystemSetting::getValue('booking_open_from');
            if ($openFrom && $validated['date'] < $openFrom) {
                return response()->json([
                    'error' => 'Bookings are not yet open for this date.'
                ], 400);
            }
    
            /* ❌ full-day closure */
            if (ClosedDay::where('date', $validated['date'])->exists()) {
                return response()->json([
                    'error' => 'The restaurant is closed on the selected date.'
                ], 400);
            }
    
            /* ❌ per-meal closure */
            if (
                MealOverride::where('date', $validated['date'])
                    ->where("{$validated['meal_type']}_closed", true)
                    ->exists()
            ) {
                return response()->json([
                    'error' => 'The selected service (lunch/dinner) is closed on that date.'
                ], 400);
            }
    
            /* run allocation algorithm */
            $partySize = $validated['total_adults'] + $validated['total_kids'];
            $longStay  = $validated['long_stay'] ?? false;
    
            $algo   = new BookingAlgorithmService();
            $assign = $algo->tryAllocate(
                $validated['date'],
                $validated['meal_type'],
                $validated['reserved_time'],
                $partySize,
                $longStay,
            );
    
            if (isset($assign['error'])) {
                return response()->json(['error' => $assign['error']], 400);
            }
    
            /* persist booking & details atomically */
            return DB::transaction(function () use ($validated, $assign, $longStay) {
                $master = null;
    
                foreach ($assign as $i => $slot) {
                    $ta = TableAvailability::where('date',        $validated['date'])
                        ->where('meal_type',   $validated['meal_type'])
                        ->where('capacity',    $slot['capacity'])
                        ->lockForUpdate()
                        ->firstOrFail();
    
                    if ($i === 0) {
                        $master = Booking::create([
                            'table_availability_id' => $ta->id,
                            'reserved_time'         => $validated['reserved_time'],
                            'total_adults'          => $validated['total_adults'],
                            'total_kids'            => $validated['total_kids'],
                            'full_name'             => $validated['full_name'],
                            'phone'                 => $validated['phone'] ?? null,
                            'email'                 => $validated['email'] ?? null,
                            'special_requests'      => $validated['special_requests'] ?? null,
                            'gdpr_consent'          => $validated['gdpr_consent'] ?? false,
                            'marketing_opt_in'      => $validated['marketing_opt_in'] ?? false,
                            'long_stay'             => $longStay,
                        ]);
                    } else {
                        BookingDetail::create([
                            'booking_id'            => $master->id,
                            'table_availability_id' => $ta->id,
                            'capacity'              => $slot['capacity'],
                            'extra_chair'           => (bool) ($slot['extra_chair'] ?? false),
                        ]);
                    }
                }
    
                /* optional e-mails */
                if ($master->email) {
                    Mail::to($master->email)->send(new BookingConfirmationMail($master));
    
                    $mealDT = Carbon::parse(
                        "{$master->tableAvailability->date} {$master->reserved_time}"
                    );
                    $remind = $mealDT->copy()->subHours(24);
                    $survey = $mealDT->copy()->addHours(3);
    
                    if ($remind->isFuture()) {
                        Mail::to($master->email)->later($remind, new BookingReminderMail($master));
                    } else {
                        Mail::to($master->email)->send(new BookingReminderMail($master));
                    }
    
                    if ($survey->isFuture()) {
                        Mail::to($master->email)->later($survey, new BookingFeedbackMail($master));
                    }
                }
    
                return response()->json([
                    'message' => 'Booked successfully!',
                    'data'    => $master->load(['tableAvailability', 'details']),
                ], 201);
            });
        }
    
        /*───────────────────────────────────────────────────────────
          Update / delete  (admin)
        ───────────────────────────────────────────────────────────*/
        public function update(Request $request, Booking $booking)
        {
            $data = $request->validate([
                'reserved_time'     => 'sometimes|date_format:H:i:s',
                'total_adults'      => 'sometimes|integer|min:1',
                'total_kids'        => 'sometimes|integer|min:0',
                'full_name'         => 'sometimes|string',
                'phone'             => 'sometimes|nullable|string',
                'email'             => 'sometimes|nullable|email',
                /* manual table move – pick any other capacity that still has stock */
                'capacity_override' => 'sometimes|integer|in:2,4,6',
            ]);
    
            return DB::transaction(function () use ($data, $booking) {
    
                $origTA   = $booking->tableAvailability;  // eager-loaded
                $date     = $origTA->date;
                $mealType = $origTA->meal_type;
    
                /*────────────────────────────────────────────────
                  1) Manual re-assign (no algorithm)
                ────────────────────────────────────────────────*/
                if (isset($data['capacity_override'])) {
                    $cap = $data['capacity_override'];
                    unset($data['capacity_override']);
    
                    $target = TableAvailability::where('date', $date)
                        ->where('meal_type', $mealType)
                        ->where('capacity', $cap)
                        ->lockForUpdate()
                        ->first();
    
                    if (! $target) {
                        return response()->json(['error' => 'No such table capacity on that date.'], 400);
                    }
    
                    $occupied = Booking::where('table_availability_id', $target->id)
                        ->where('id', '!=', $booking->id)
                        ->count();
    
                    if ($occupied >= $target->available_count) {
                        return response()->json(['error' => 'No free table of that capacity.'], 400);
                    }
    
                    $booking->table_availability_id = $target->id;
                }
    
                /*────────────────────────────────────────────────
                  2) Fields that may require re-allocation
                ────────────────────────────────────────────────*/
                $partyChanged = array_key_exists('total_adults', $data)
                    || array_key_exists('total_kids', $data);
                $timeChanged  = array_key_exists('reserved_time', $data);
    
                if ($partyChanged || $timeChanged) {
                    $partySize = ($data['total_adults'] ?? $booking->total_adults)
                        + ($data['total_kids']   ?? $booking->total_kids);
                    $timeHHMM  = $data['reserved_time'] ?? $booking->reserved_time;
                    $longStay  = $booking->long_stay;
    
                    $algo   = new BookingAlgorithmService();
                    $assign = $algo->tryAllocate(
                        $date,
                        $mealType,
                        $timeHHMM,
                        $partySize,
                        $longStay
                    );
    
                    if (isset($assign['error'])) {
                        return response()->json(['error' => $assign['error']], 400);
                    }
    
                    // Remove existing extra-details
                    $booking->details()->delete();
    
                    // Persist new assignment
                    $first = true;
                    foreach ($assign as $slot) {
                        $ta = TableAvailability::where('date',      $date)
                            ->where('meal_type', $mealType)
                            ->where('capacity',  $slot['capacity'])
                            ->lockForUpdate()
                            ->firstOrFail();
    
                        if ($first) {
                            $booking->update([
                                'table_availability_id' => $ta->id,
                                'reserved_time'         => $timeHHMM,
                                'total_adults'          => $data['total_adults'] ?? $booking->total_adults,
                                'total_kids'            => $data['total_kids']   ?? $booking->total_kids,
                                'full_name'             => $data['full_name']    ?? $booking->full_name,
                                'phone'                 => $data['phone']        ?? $booking->phone,
                                'email'                 => $data['email']        ?? $booking->email,
                            ]);
                            $first = false;
                        } else {
                            BookingDetail::create([
                                'booking_id'            => $booking->id,
                                'table_availability_id' => $ta->id,
                                'capacity'              => $slot['capacity'],
                                'extra_chair'           => (bool) ($slot['extra_chair'] ?? false),
                            ]);
                        }
                    }
                } else {
                    // No re-allocation needed: just update other fields
                    $booking->update($data);
                }
    
                return response()->json([
                    'message' => 'booking updated',
                    'data'    => $booking->fresh(['tableAvailability', 'details']),
                ]);
            });
        }
    
        public function destroy(Booking $booking)
        {
            $booking->delete();
            return response()->json(['message' => 'booking deleted']);
        }
    }

––––––––––––––––––––––––
backend/app/Http/Controllers/Controller.php
    <?php
    
    namespace App\Http\Controllers;
    
    use Illuminate\Foundation\Auth\Access\AuthorizesRequests;
    use Illuminate\Foundation\Validation\ValidatesRequests;
    use Illuminate\Routing\Controller as BaseController;
    
    class Controller extends BaseController
    {
        use AuthorizesRequests, ValidatesRequests;
    }

––––––––––––––––––––––––
backend/app/Http/Controllers/TableAvailabilityController.php
    <?php
    
    namespace App\Http\Controllers;
    
    use App\Models\TableAvailability;
    use App\Models\Booking;
    use App\Models\ClosedDay;
    use App\Models\SystemSetting;
    use App\Models\MealOverride;                       // ← NEW
    use Illuminate\Http\Request;
    use Illuminate\Support\Carbon;
    use Illuminate\Support\Facades\Config;
    use App\Services\CalendarService;
    
    /**
     * Table-availability endpoints
     */
    class TableAvailabilityController extends Controller
    {
        private const CLOSED_INDICATOR  = 'closed';
        private const BLOCKED_INDICATOR = 'blocked';
    
        private CalendarService $calendar;
    
        public function __construct(CalendarService $calendar)
        {
            $this->calendar = $calendar;
        }
    
        /*────────────────── helpers ──────────────────*/
        private function minutesStep(): int
        {
            $step = Config::get('restaurant.slot_step');
            if ($step === null) {
                throw new \RuntimeException('Missing config: restaurant.slot_step');
            }
            return (int) $step;
        }
    
        private function serviceSchedule(): array
        {
            return Config::get('restaurant_dataset.service_schedule', []);
        }
    
        private function buildTimeGrid(string $start, string $end): array
        {
            [$sh, $sm] = array_map('intval', explode(':', $start));
            [$eh, $em] = array_map('intval', explode(':', $end));
    
            $slots = [];
            for ($m = $sh * 60 + $sm; $m <= $eh * 60 + $em; $m += $this->minutesStep()) {
                $slots[] = sprintf('%02d:%02d', intdiv($m, 60), $m % 60);
            }
            return $slots;
        }
    
        private function computeRoundAvailability($tableAvailabilities, array $roundTimes, $allBookings = null)
        {
            if ($allBookings === null) {
                $ids         = $tableAvailabilities->pluck('id');
                $allBookings = Booking::whereIn('table_availability_id', $ids)->get();
            }
    
            $caps     = Config::get('restaurant.capacities', [2, 4, 6]);
            $isSecond = in_array(
                Config::get('restaurant.rounds.lunch.second_round.start'),
                $roundTimes,
                true
            );
    
            $availability = [];
            foreach ($caps as $cap) {
                $taRow  = $tableAvailabilities->firstWhere('capacity', $cap);
                $seeded = $taRow?->available_count ?? 0;
                $booked = $allBookings
                    ->where('table_availability_id', $taRow?->id)
                    ->filter(function ($b) use ($roundTimes, $isSecond) {
                        if (in_array($b->reserved_time, $roundTimes, true)) {
                            return true;
                        }
                        return $isSecond && $b->long_stay && $b->reserved_time < $roundTimes[0];
                    })
                    ->count();
    
                $availability["$cap"] = max($seeded - $booked, 0);
            }
    
            return $availability;
        }
    
        /*────────────────── single-day endpoint ──────────────────*/
        public function index(Request $request)
        {
            $date     = trim($request->query('date', ''));
            $mealType = trim($request->query('mealType', ''));
    
            if (! $date || ! in_array($mealType, ['lunch', 'dinner'], true)) {
                return response()->json([], 400);
            }
    
            /* seed stock if needed */
            $this->calendar->ensureStockForDate($date);
    
            /* quick-out indicators */
            if (ClosedDay::where('date', $date)->exists()) {
                return response()->json(self::CLOSED_INDICATOR);
            }
            if (
                MealOverride::where('date', $date)
                    ->where("{$mealType}_closed", true)
                    ->exists()
            ) {
                return response()->json(self::CLOSED_INDICATOR);
            }
            $openFrom = SystemSetting::getValue('booking_open_from');
            if ($openFrom && $date < $openFrom) {
                return response()->json(self::BLOCKED_INDICATOR);
            }
    
            /* normal availability build */
            $rows = TableAvailability::where('date', $date)
                ->where('meal_type', $mealType)
                ->get()
                ->keyBy('capacity');
    
            if ($rows->isEmpty()) {
                return response()->json([]);
            }
    
            $roundCfg = Config::get("restaurant.rounds.$mealType");
            $payload  = [];
    
            foreach ($roundCfg as $key => $def) {
                $times         = $this->buildTimeGrid($def['start'], $def['end']);
                $payload[$key] = [
                    'time'         => $def['start'],
                    'availability' => $this->computeRoundAvailability($rows, $times),
                    'note'         => $def['note'],
                ];
            }
    
            return response()->json($payload);
        }
    
        /*────────────────── multi-day endpoint ──────────────────*/
        public function range(Request $request)
        {
            $start    = $request->query('start');
            $end      = $request->query('end');
            $mealType = $request->query('mealType');
    
            if (! $start || ! $end || ! in_array($mealType, ['lunch', 'dinner'], true)) {
                return response()->json(['error' => 'Missing parameters (start,end,mealType)'], 400);
            }
    
            $startDate = Carbon::parse($start);
            $endDate   = Carbon::parse($end);
            if ($endDate->lt($startDate)) {
                return response()->json(['error' => 'end must be after start'], 400);
            }
    
            /* seed stock for each date in range */
            for ($d = $startDate->copy(); $d->lte($endDate); $d->addDay()) {
                $this->calendar->ensureStockForDate($d->format('Y-m-d'));
            }
    
            $rows = TableAvailability::whereBetween('date', [$start, $end])
                ->where('meal_type', $mealType)
                ->get();
    
            $availabilityIds = $rows->pluck('id');
            $bookings        = Booking::whereIn('table_availability_id', $availabilityIds)->get();
    
            $roundCfg = Config::get("restaurant.rounds.$mealType");
            $schedule = $this->serviceSchedule();
            $openFrom = SystemSetting::getValue('booking_open_from');
            $results  = [];
    
            $cursor = $startDate->copy();
            while ($cursor->lte($endDate)) {
                $dateStr = $cursor->format('Y-m-d');
    
                /* full day closed? */
                if (ClosedDay::where('date', $dateStr)->exists()) {
                    $results[$dateStr] = self::CLOSED_INDICATOR;
                    $cursor->addDay();
                    continue;
                }
    
                /* per-meal closed? */
                if (
                    MealOverride::where('date', $dateStr)
                        ->where("{$mealType}_closed", true)
                        ->exists()
                ) {
                    $results[$dateStr] = self::CLOSED_INDICATOR;
                    $cursor->addDay();
                    continue;
                }
    
                /* booking window not open yet? */
                if ($openFrom && $dateStr < $openFrom) {
                    $results[$dateStr] = self::BLOCKED_INDICATOR;
                    $cursor->addDay();
                    continue;
                }
    
                /* weekly schedule */
                $dow         = $cursor->dayOfWeek;
                $servedMeals = $schedule[$dow] ?? [];
                if (empty($servedMeals)) {
                    $results[$dateStr] = self::CLOSED_INDICATOR;
                    $cursor->addDay();
                    continue;
                }
                if (! in_array($mealType, $servedMeals, true)) {
                    $results[$dateStr] = [];
                    $cursor->addDay();
                    continue;
                }
    
                /* build availability */
                $dayRows = $rows->where('date', $dateStr);
                if ($dayRows->isEmpty()) {
                    $results[$dateStr] = [];
                    $cursor->addDay();
                    continue;
                }
    
                $payload = [];
                foreach ($roundCfg as $key => $def) {
                    $grid = $this->buildTimeGrid($def['start'], $def['end']);
                    $payload[$key] = [
                        'time'         => $def['start'],
                        'availability' => $this->computeRoundAvailability($dayRows, $grid, $bookings),
                        'note'         => $def['note'],
                    ];
                }
                $results[$dateStr] = $payload;
                $cursor->addDay();
            }
    
            return response()->json($results);
        }
    }

––––––––––––––––––––––––
backend/app/Http/Controllers/OpenDayController.php
    <?php
    
    namespace App\Http\Controllers;
    
    use App\Models\OpenDay;
    use Illuminate\Http\Request;
    use App\Services\CalendarService;
    
    class OpenDayController extends Controller
    {
        private CalendarService $calendar;
    
        public function __construct(CalendarService $calendar)
        {
            $this->calendar = $calendar;
        }
    
        /** GET /api/open-days */
        public function index()
        {
            return response()->json(
                OpenDay::orderBy('date')->pluck('date')
            );
        }
    
        /** POST /api/open-days/toggle  { date: YYYY-MM-DD } */
        public function toggle(Request $request)
        {
            $date = $request->validate([
                'date' => 'required|date_format:Y-m-d',
            ])['date'];
    
            $existing = OpenDay::find($date);
    
            if ($existing) {
                // remove open-exception
                $existing->delete();
                $state = 'removed';
            } else {
                // add open-exception and make sure stock exists
                OpenDay::create(['date' => $date]);
                $this->calendar->ensureStockForDate($date);
                $state = 'added';
            }
    
            return response()->json(compact('date', 'state'));
        }
    }

––––––––––––––––––––––––
backend/app/Http/Controllers/ClosedDayController.php
    <?php
    
    namespace App\Http\Controllers;
    
    use App\Models\ClosedDay;
    use Illuminate\Http\Request;
    use App\Services\CalendarService;
    
    class ClosedDayController extends Controller
    {
        private CalendarService $calendar;
    
        public function __construct(CalendarService $calendar)
        {
            $this->calendar = $calendar;
        }
    
        /** GET /api/closed-days */
        public function index()
        {
            return response()->json(
                ClosedDay::orderBy('date')->pluck('date')
            );
        }
    
        /** POST /api/closed-days/toggle {date} */
        public function toggle(Request $request)
        {
            $date = $request->validate([
                'date' => 'required|date_format:Y-m-d',
            ])['date'];
    
            $existing = ClosedDay::find($date);
    
            if ($existing) {
                // RE-OPEN day: delete flag and regenerate stock
                $existing->delete();
                $this->calendar->ensureStockForDate($date);
                $state = 'opened';
            } else {
                // CLOSE day: create flag (no further action)
                ClosedDay::create(['date' => $date]);
                $state = 'closed';
            }
    
            return response()->json([
                'date'  => $date,
                'state' => $state,
            ]);
        }
    }

––––––––––––––––––––––––
backend/app/Http/Controllers/SystemSettingController.php
    <?php
    
    namespace App\Http\Controllers;
    
    use App\Models\SystemSetting;
    use Illuminate\Http\Request;
    
    /**
     * Currently only exposes “booking_open_from”
     */
    class SystemSettingController extends Controller
    {
        /** GET /api/settings/booking-open-from */
        public function show()
        {
            return response()->json([
                'booking_open_from' => SystemSetting::getValue('booking_open_from'),
            ]);
        }
    
        /** PUT /api/settings/booking-open-from */
        public function update(Request $request)
        {
            $date = $request->validate([
                'booking_open_from' => 'required|date_format:Y-m-d',
            ])['booking_open_from'];
    
            SystemSetting::setValue('booking_open_from', $date);
    
            return response()->json(['booking_open_from' => $date]);
        }
    }

––––––––––––––––––––––––
backend/app/Http/Resources/BookingDetailResource.php
    <?php
    
    namespace App\Http\Resources;
    
    use Illuminate\Http\Resources\Json\JsonResource;
    
    class BookingDetailResource extends JsonResource
    {
        /**
         * Transform the resource into an array.
         *
         * @param  \Illuminate\Http\Request  $request
         * @return array
         */
        public function toArray($request)
        {
            return [
                'id'                     => $this->id,
                'capacity'              => $this->capacity,
                'extra_chair'           => (bool) $this->extra_chair,
                'table_availability_id' => $this->table_availability_id,
                // Optional: You could nest further details about TableAvailability here.
                'table_availability'    => $this->whenLoaded('tableAvailability', [
                    'date'       => $this->tableAvailability->date,
                    'meal_type'  => $this->tableAvailability->meal_type,
                    'capacity'   => $this->tableAvailability->capacity,
                ]),
            ];
        }
    }

––––––––––––––––––––––––
backend/app/Http/Resources/BookingResource.php
    <?php
    
    namespace App\Http\Resources;
    
    use Illuminate\Http\Resources\Json\JsonResource;
    
    class BookingResource extends JsonResource
    {
        /**
         * Transform the resource into an array.
         *
         * @param  \Illuminate\Http\Request  $request
         * @return array
         */
        public function toArray($request)
        {
            return [
                'id'            => $this->id,
                'date'          => $this->date,
                'time'          => $this->time,
                'customer_name' => $this->customer_name,
                'guest_count'   => $this->guest_count,
                'details'       => BookingDetailResource::collection($this->whenLoaded('details')),
                'created_at'    => $this->created_at,
                'updated_at'    => $this->updated_at,
            ];
        }
    }

––––––––––––––––––––––––
backend/app/Http/Resources/TableAvailabilityResource.php
    <?php
    
    namespace App\Http\Resources;
    
    use Illuminate\Http\Resources\Json\JsonResource;
    
    /**
     * A flexible resource to wrap availability data.
     * Since we're computing availability arrays on-the-fly,
     * this resource can simply return the array structure.
     */
    class TableAvailabilityResource extends JsonResource
    {
        /**
         * Transform the resource into an array.
         *
         * Because this resource is sometimes used to return a single-day
         * structure and other times used for a multi-day structure (range),
         * we simply return $this->resource as-is.
         *
         * @param \Illuminate\Http\Request $request
         * @return array
         */
        public function toArray($request)
        {
            // $this->resource is the array from the controller
            return $this->resource;
        }
    }

––––––––––––––––––––––––
backend/app/Http/Kernel.php
    <?php
    
    namespace App\Http;
    
    use Illuminate\Foundation\Http\Kernel as HttpKernel;
    
    class Kernel extends HttpKernel
    {
        /**
         * The application's global HTTP middleware stack.
         *
         * These middleware are run during every request to your application.
         *
         * @var array<int, class-string|string>
         */
        protected $middleware = [
            // \App\Http\Middleware\TrustHosts::class,
            \App\Http\Middleware\TrustProxies::class,
            \Illuminate\Http\Middleware\HandleCors::class,
            \App\Http\Middleware\PreventRequestsDuringMaintenance::class,
            \Illuminate\Foundation\Http\Middleware\ValidatePostSize::class,
            \App\Http\Middleware\TrimStrings::class,
            \Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull::class,
            \App\Http\Middleware\HandleCors::class,
        ];
    
        /**
         * The application's route middleware groups.
         *
         * @var array<string, array<int, class-string|string>>
         */
        protected $middlewareGroups = [
            'web' => [
                \App\Http\Middleware\EncryptCookies::class,
                \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
                \Illuminate\Session\Middleware\StartSession::class,
                \Illuminate\View\Middleware\ShareErrorsFromSession::class,
                \App\Http\Middleware\VerifyCsrfToken::class,
                \Illuminate\Routing\Middleware\SubstituteBindings::class,
            ],
    
            'api' => [
                // \Laravel\Sanctum\Http\Middleware\EnsureFrontendRequestsAreStateful::class,
                \Illuminate\Routing\Middleware\ThrottleRequests::class.':api',
                \Illuminate\Routing\Middleware\SubstituteBindings::class,
            ],
        ];
    
        /**
         * The application's middleware aliases.
         *
         * Aliases may be used instead of class names to conveniently assign middleware to routes and groups.
         *
         * @var array<string, class-string|string>
         */
        protected $middlewareAliases = [
            'auth' => \App\Http\Middleware\Authenticate::class,
            'auth.basic' => \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,
            'auth.session' => \Illuminate\Session\Middleware\AuthenticateSession::class,
            'cache.headers' => \Illuminate\Http\Middleware\SetCacheHeaders::class,
            'can' => \Illuminate\Auth\Middleware\Authorize::class,
            'guest' => \App\Http\Middleware\RedirectIfAuthenticated::class,
            'password.confirm' => \Illuminate\Auth\Middleware\RequirePassword::class,
            'precognitive' => \Illuminate\Foundation\Http\Middleware\HandlePrecognitiveRequests::class,
            'signed' => \App\Http\Middleware\ValidateSignature::class,
            'throttle' => \Illuminate\Routing\Middleware\ThrottleRequests::class,
            'verified' => \Illuminate\Auth\Middleware\EnsureEmailIsVerified::class,
        ];
    }

––––––––––––––––––––––––
backend/app/Mail/BookingConfirmationMail.php
    <?php
    
    namespace App\Mail;
    
    use App\Models\Booking;
    use Illuminate\Bus\Queueable;
    use Illuminate\Mail\Mailable;
    use Illuminate\Queue\SerializesModels;
    
    class BookingConfirmationMail extends Mailable
    {
        use Queueable, SerializesModels;
    
        public Booking $booking;
    
        /**
         * Create a new message instance.
         */
        public function __construct(Booking $booking)
        {
            $this->booking = $booking;
        }
    
        /**
         * Build the message (no Blade view, inline HTML).
         */
        public function build()
        {
            $meal = $this->booking->tableAvailability->meal_type === 'lunch'
                ? 'Comida'
                : 'Cena';
    
            return $this
                ->subject('Reserva confirmada – ¡gracias por elegirnos!')
                ->html("
                    <style>
                        body{font-family:Arial,Helvetica,sans-serif;color:#222;margin:0;padding:0}
                        .box{max-width:600px;margin:0 auto;padding:24px}
                        h1{margin-top:0;color:#d97706;font-size:22px}
                        ul{padding-left:18px}
                        li{margin:4px 0}
                    </style>
    
                    <div class='box'>
                        <h1>Estimado/a {$this->booking->full_name},</h1>
    
                        <p>
                            Nos complace confirmar su reserva. A continuación encontrará
                            los detalles:
                        </p>
    
                        <ul>
                            <li><strong>Fecha:</strong> {$this->booking->tableAvailability->date}</li>
                            <li><strong>Servicio:</strong> {$meal}</li>
                            <li><strong>Hora:</strong> {$this->booking->reserved_time}</li>
                            <li><strong>N.º de comensales:</strong> " .
                    ($this->booking->total_adults + $this->booking->total_kids) . "</li>
                        </ul>
    
                        <p>
                            Le rogamos que llegue con puntualidad. Si necesita modificar o
                            cancelar la reserva, responda a este correo o llámenos al teléfono
                            del restaurante.
                        </p>
    
                        <p>¡Le esperamos!</p>
    
                        <p style='margin-top:32px;font-size:14px;color:#555'>
                            — Equipo de Atención al Cliente
                        </p>
                    </div>
                ");
        }
    }

––––––––––––––––––––––––
backend/app/Mail/BookingFeedbackMail.php
    <?php
    
    namespace App\Mail;
    
    use App\Models\Booking;
    use Illuminate\Bus\Queueable;
    use Illuminate\Mail\Mailable;
    use Illuminate\Queue\SerializesModels;
    
    class BookingFeedbackMail extends Mailable
    {
        use Queueable, SerializesModels;
    
        public Booking $booking;
    
        public function __construct(Booking $booking)
        {
            $this->booking = $booking;
        }
    
        public function build()
        {
            return $this
                ->subject('¿Cómo fue su experiencia con nosotros?')
                ->html("
                    <style>
                        body{font-family:Arial,Helvetica,sans-serif;color:#222;margin:0;padding:0}
                        .box{max-width:600px;margin:0 auto;padding:24px}
                        h1{margin-top:0;color:#2563eb;font-size:22px}
                    </style>
    
                    <div class='box'>
                        <h1>Gracias por su visita, {$this->booking->full_name}.</h1>
    
                        <p>
                            Su opinión es muy valiosa para nosotros. Le agradeceríamos que
                            dedicara un minuto a contarnos cómo fue todo.
                        </p>
    
                        <p>
                            <a href='#' style='background:#2563eb;color:#fff;padding:10px 18px;border-radius:4px;text-decoration:none'>
                                Enviar valoración
                            </a>
                        </p>
    
                        <p style='margin-top:32px;font-size:14px;color:#555'>
                            — Equipo de Atención al Cliente
                        </p>
                    </div>
                ");
        }
    }

––––––––––––––––––––––––
backend/app/Mail/BookingReminderMail.php
    <?php
    
    namespace App\Mail;
    
    use App\Models\Booking;
    use Illuminate\Bus\Queueable;
    use Illuminate\Mail\Mailable;
    use Illuminate\Queue\SerializesModels;
    
    class BookingReminderMail extends Mailable
    {
        use Queueable, SerializesModels;
    
        public Booking $booking;
    
        public function __construct(Booking $booking)
        {
            $this->booking = $booking;
        }
    
        public function build()
        {
            $meal = $this->booking->tableAvailability->meal_type === 'lunch'
                ? 'Comida'
                : 'Cena';
    
            return $this
                ->subject('Recordatorio: su reserva es mañana')
                ->html("
                    <style>
                        body{font-family:Arial,Helvetica,sans-serif;color:#222;margin:0;padding:0}
                        .box{max-width:600px;margin:0 auto;padding:24px}
                        h1{margin-top:0;color:#0f766e;font-size:22px}
                        ul{padding-left:18px}
                        li{margin:4px 0}
                    </style>
    
                    <div class='box'>
                        <h1>¡Mañana es el gran día!</h1>
    
                        <p>
                            {$this->booking->full_name}, le recordamos su reserva confirmada:
                        </p>
    
                        <ul>
                            <li><strong>Fecha:</strong> {$this->booking->tableAvailability->date}</li>
                            <li><strong>Servicio:</strong> {$meal}</li>
                            <li><strong>Hora:</strong> {$this->booking->reserved_time}</li>
                        </ul>
    
                        <p>
                            Si necesita realizar cambios, por favor conteste a este correo
                            o llámenos. ¡Hasta pronto!
                        </p>
    
                        <p style='margin-top:32px;font-size:14px;color:#555'>
                            — Equipo de Atención al Cliente
                        </p>
                    </div>
                ");
        }
    }

––––––––––––––––––––––––
backend/app/Models/Booking.php
    <?php
    
    namespace App\Models;
    
    use Illuminate\Database\Eloquent\Factories\HasFactory;
    use Illuminate\Database\Eloquent\Model;
    
    class Booking extends Model
    {
        use HasFactory;
    
        protected $fillable = [
            'table_availability_id',
            'reserved_time',
            'total_adults',
            'total_kids',
            'full_name',
            'phone',
            'email',
            'special_requests',
            'gdpr_consent',
            'marketing_opt_in',
            'long_stay',
        ];
    
        /* ──────────── relations ──────────── */
    
        public function tableAvailability()
        {
            return $this->belongsTo(TableAvailability::class);
        }
    
        /** extra tables when one party spans several tables */
        public function details()
        {
            return $this->hasMany(BookingDetail::class);
        }
    }

––––––––––––––––––––––––
backend/app/Models/BookingDetail.php
    <?php
    
    namespace App\Models;
    
    use Illuminate\Database\Eloquent\Factories\HasFactory;
    use Illuminate\Database\Eloquent\Model;
    
    class BookingDetail extends Model
    {
        use HasFactory;
    
        protected $fillable = [
            'booking_id',
            'table_availability_id',
            'capacity',
            'extra_chair',
        ];
    
        /**
         * BookingDetail belongs to a master booking.
         */
        public function booking()
        {
            return $this->belongsTo(Booking::class);
        }
    
        /**
         * BookingDetail references a TableAvailability record.
         */
        public function tableAvailability()
        {
            return $this->belongsTo(TableAvailability::class);
        }
    }

––––––––––––––––––––––––
backend/app/Models/TableAvailability.php
    <?php
    
    namespace App\Models;
    
    use Illuminate\Database\Eloquent\Factories\HasFactory;
    use Illuminate\Database\Eloquent\Model;
    
    class TableAvailability extends Model
    {
        use HasFactory;
    
        protected $fillable = [
            'date',
            'meal_type',
            'capacity',
            'available_count',
            'position',
        ];
    
        public function bookings()
        {
            return $this->hasMany(Booking::class);
        }
    }

––––––––––––––––––––––––
backend/app/Models/User.php
    <?php
    
    namespace App\Models;
    
    // use Illuminate\Contracts\Auth\MustVerifyEmail;
    use Illuminate\Database\Eloquent\Factories\HasFactory;
    use Illuminate\Foundation\Auth\User as Authenticatable;
    use Illuminate\Notifications\Notifiable;
    use Laravel\Sanctum\HasApiTokens;
    
    class User extends Authenticatable
    {
        use HasApiTokens, HasFactory, Notifiable;
    
        /**
         * The attributes that are mass assignable.
         *
         * @var array<int, string>
         */
        protected $fillable = [
            'name',
            'email',
            'password',
        ];
    
        /**
         * The attributes that should be hidden for serialization.
         *
         * @var array<int, string>
         */
        protected $hidden = [
            'password',
            'remember_token',
        ];
    
        /**
         * The attributes that should be cast.
         *
         * @var array<string, string>
         */
        protected $casts = [
            'email_verified_at' => 'datetime',
            'password' => 'hashed',
        ];
    }

––––––––––––––––––––––––
backend/app/Models/ClosedDay.php
    <?php
    
    namespace App\Models;
    
    use Illuminate\Database\Eloquent\Model;
    
    /**
     * Simple key-only model that stores a date when the whole
     * restaurant is closed (e.g. public holiday).
     */
    class ClosedDay extends Model
    {
        public $timestamps     = false;
        protected $primaryKey  = 'date';
        public    $incrementing = false;
        protected $keyType     = 'string';
    
        protected $fillable = ['date'];
    }

––––––––––––––––––––––––
backend/app/Models/OpenDay.php
    <?php
    
    namespace App\Models;
    
    use Illuminate\Database\Eloquent\Model;
    
    class OpenDay extends Model
    {
        public $incrementing = false;
        public $timestamps   = true;
        protected $primaryKey = 'date';
        protected $keyType    = 'string';      // “YYYY-MM-DD”
        protected $fillable   = ['date'];
    }

––––––––––––––––––––––––
backend/app/Models/SystemSetting.php
    <?php
    
    namespace App\Models;
    
    use Illuminate\Database\Eloquent\Model;
    
    /**
     * Generic key-value store for runtime-tunable settings
     */
    class SystemSetting extends Model
    {
        public    $timestamps   = false;
        protected $primaryKey   = 'key';
        public    $incrementing = false;
        protected $keyType      = 'string';
    
        protected $fillable = ['key','value'];
    
        public static function getValue(string $key, mixed $default = null): mixed
        {
            $row = static::find($key);
            return $row?->value ?? $default;
        }
    
        public static function setValue(string $key, string $value): void
        {
            static::updateOrCreate(['key'=>$key], ['value'=>$value]);
        }
    }

––––––––––––––––––––––––
backend/app/Services/BookingAlgorithmService.php
    <?php
    
    namespace App\Services;
    
    use App\Models\TableAvailability;
    use App\Models\Booking;
    use Illuminate\Support\Facades\Config;
    use Illuminate\Support\Facades\DB;
    
    /**
     * Deterministic “smallest-waste” allocation engine.
     *
     * Signature matches what the controller already expects:
     *   tryAllocate($date, $mealType, $reservedTime, $partySize, $longStay = false): array
     *
     * It returns a list like
     *   [
     *     ['capacity' => 4, 'extra_chair' => false],
     *     ['capacity' => 2, 'extra_chair' => true],
     *   ]
     * or `['error' => '…']` when seating is impossible.
     */
    class BookingAlgorithmService
    {
        private array $cfg;
        private array $capacities;
        private array $epsMap;
    
        public function __construct()
        {
            $this->cfg        = Config::get('restaurant');
            $this->capacities = $this->cfg['capacities']     ?? [2, 4, 6];
            $this->epsMap     = $this->cfg['party_to_eps']   ?? [];
        }
    
        /*───────────────────────────────────────────────────────────
         | Public API – called from BookingController
         *───────────────────────────────────────────────────────────*/
        public function tryAllocate(
            string $date,
            string $mealType,
            string $reservedTime,
            int    $partySize,
            bool   $longStay = false
        ): array {
            return DB::transaction(function () use ($date, $mealType, $reservedTime, $partySize, $longStay) {
    
                /* ── lock stock rows for this service ───────────────────*/
                $rows = TableAvailability::where('date', $date)
                    ->where('meal_type', $mealType)
                    ->lockForUpdate()
                    ->get()
                    ->keyBy('capacity');
    
                if ($rows->isEmpty()) {
                    return ['error' => 'No tables configured for the selected date / service.'];
                }
    
                /* ── free-table counts for the chosen round ─────────────*/
                $roundKey   = $this->detectRound($reservedTime, $mealType);
                $roundTimes = $this->roundTimeWindow($mealType, $roundKey);
    
                $free = [];
                foreach ($this->capacities as $cap) {
                    $row = $rows->get($cap);
                    if (! $row) {
                        $free[$cap] = 0;
                        continue;
                    }
    
                    // bookings occupying this capacity in the *same* round
                    $booked = Booking::where('table_availability_id', $row->id)
                        ->whereBetween('reserved_time', [$roundTimes['start'], $roundTimes['end']])
                        ->count();
    
                    // spill-over from 1st → 2nd lunch when long-stay
                    if ($roundKey === 'second_round') {
                        $booked += Booking::where('table_availability_id', $row->id)
                            ->where('reserved_time', '<', $roundTimes['start'])
                            ->where('long_stay', true)
                            ->count();
                    }
    
                    $free[$cap] = max($row->available_count - $booked, 0);
                }
    
                /* ── greedy “smallest-waste” packer ─────────────────────*/
                $required = $partySize;
                $assign   = [];
    
                sort($this->capacities);                // 2 → 4 → 6, always
    
                while ($required > 0) {
    
                    $eps = $this->epsMap[$required] ?? 0;
                    $bestCap = null;
    
                    /* ① perfect / ε-fit on the smallest possible table */
                    foreach ($this->capacities as $cap) {
                        if ($free[$cap] <= 0) {
                            continue;
                        }
                        if ($required <= $cap && ($cap - $required) <= $eps) {
                            $bestCap = $cap;
                            break;
                        }
                    }
    
                    /* ② otherwise: largest table that is ≤ seats-remaining */
                    if ($bestCap === null) {
                        foreach (array_reverse($this->capacities) as $cap) {
                            if ($free[$cap] > 0 && $cap <= $required) {
                                $bestCap = $cap;
                                break;
                            }
                        }
                    }
    
                    /* ③ still nothing? grab the absolutely smallest free table */
                    if ($bestCap === null) {
                        foreach ($this->capacities as $cap) {
                            if ($free[$cap] > 0) {
                                $bestCap = $cap;
                                break;
                            }
                        }
                    }
    
                    if ($bestCap === null) {
                        return ['error' => 'Not enough free tables to seat this party.'];
                    }
    
                    /* record assignment */
                    $extraChair = ($required > $bestCap);        // ε case
                    $assign[]   = [
                        'capacity'    => $bestCap,
                        'extra_chair' => $extraChair,
                    ];
    
                    /* update counters */
                    $free[$bestCap]--;
                    $required -= min($required, $bestCap);
                }
    
                return $assign;
            });
        }
    
        /*───────────────────────────────────────────────────────────
         | Helpers
         *───────────────────────────────────────────────────────────*/
        public function detectRound(string $hhmmss, string $meal): string
        {
            [$h, $m] = array_map('intval', explode(':', substr($hhmmss, 0, 5)));
            $time    = sprintf('%02d:%02d', $h, $m);
            $rounds  = $this->cfg['rounds'][$meal];
    
            if ($meal === 'lunch') {
                return ($time < $rounds['second_round']['start'])
                    ? 'first_round'
                    : 'second_round';
            }
    
            return 'dinner_round';
        }
    
        private function roundTimeWindow(string $meal, string $round): array
        {
            $def = $this->cfg['rounds'][$meal][$round] ?? ['start' => '00:00', 'end' => '23:59'];
            return [
                'start' => $def['start'] . ':00',
                'end'   => $def['end']   . ':00',
            ];
        }
    }

––––––––––––––––––––––––
backend/app/Services/CalendarService.php
    <?php
    
    namespace App\Services;
    
    use App\Models\TableAvailability;
    use App\Models\ClosedDay;
    use App\Models\OpenDay;
    use App\Models\SystemSetting;
    use Illuminate\Support\Carbon;
    use Illuminate\Support\Facades\Config;
    
    class CalendarService
    {
        /**
         * Create TableAvailability rows for $date if they don't exist.
         */
        public function ensureStockForDate(string $date): void
        {
            if (TableAvailability::where('date', $date)->exists()) {
                return;   // already seeded
            }
    
            $dow       = Carbon::parse($date)->dayOfWeek;           // 0=Sun…6=Sat
            $mealTypes = Config::get("restaurant_dataset.service_schedule.{$dow}", []);
    
            foreach ($mealTypes as $meal) {
                foreach (Config::get('restaurant_dataset.table_types', []) as $type) {
                    TableAvailability::create([
                        'date'            => $date,
                        'meal_type'       => $meal,
                        'capacity'        => $type['capacity'],
                        'available_count' => $type['available_count'],
                    ]);
                }
            }
        }
    
        /**
         * True ⇢ restaurant should accept bookings on $date.
         */
        public function isOpen(string $date): bool
        {
            /* 1) explicit manual close beats everything */
            if (ClosedDay::where('date', $date)->exists()) {
                return false;
            }
    
            /* 2) explicit manual open beats weekly schedule */
            if (OpenDay::where('date', $date)->exists()) {
                return true;
            }
    
            /* 3) global booking-window not yet open? */
            $openFrom = SystemSetting::getValue('booking_open_from');
            if ($openFrom && $date < $openFrom) {
                return false;
            }
    
            /* 4) fall back to weekly service_schedule */
            $dow   = Carbon::parse($date)->dayOfWeek;
            $meals = Config::get("restaurant_dataset.service_schedule.{$dow}", []);
    
            return ! empty($meals);
        }
    }

––––––––––––––––––––––––
backend/database/migrations/2025_02_03_191203_create_table_availabilities_table.php
    <?php
    
    use Illuminate\Database\Migrations\Migration;
    use Illuminate\Database\Schema\Blueprint;
    use Illuminate\Support\Facades\Schema;
    
    return new class extends Migration
    {
        public function up(): void
        {
            Schema::create('table_availabilities', function (Blueprint $table) {
                $table->id();
                $table->date('date');
                $table->string('meal_type');        // lunch or dinner
                $table->integer('capacity');        // e.g. 2, 4, or 6
                $table->integer('available_count'); // number of available tables for that capacity
                $table->timestamps();
    
                // each date+meal_type+capacity is unique
                $table->unique(['date', 'meal_type', 'capacity']);
            });
        }
    
        public function down(): void
        {
            Schema::dropIfExists('table_availabilities');
        }
    };

––––––––––––––––––––––––
backend/database/migrations/2025_02_04_115733_create_bookings_table.php
    <?php
    
    use Illuminate\Database\Migrations\Migration;
    use Illuminate\Database\Schema\Blueprint;
    use Illuminate\Support\Facades\Schema;
    
    return new class extends Migration
    {
        public function up(): void
        {
            Schema::create('bookings', function (Blueprint $table) {
                $table->id();
                $table->foreignId('table_availability_id')->constrained()->onDelete('cascade');
    
                // Instead of storing date/time, we only store the chosen time.
                // (The date is in table_availability.)
                $table->time('reserved_time');
    
                // Breakdown of guests
                $table->unsignedInteger('total_adults')->default(1);
                $table->unsignedInteger('total_kids')->default(0);
    
                // Contact & personal info
                $table->string('full_name');
                $table->string('phone')->nullable();
                $table->string('email')->nullable();
                $table->text('special_requests')->nullable();
    
                // Consents
                $table->boolean('gdpr_consent')->default(false);
                $table->boolean('marketing_opt_in')->default(false);
    
                $table->timestamps();
            });
        }
    
        public function down(): void
        {
            Schema::dropIfExists('bookings');
        }
    };

––––––––––––––––––––––––
backend/database/migrations/2025_02_26_163537_create_booking_details_table.php
    <?php
    
    use Illuminate\Database\Migrations\Migration;
    use Illuminate\Database\Schema\Blueprint;
    use Illuminate\Support\Facades\Schema;
    
    return new class extends Migration
    {
        /**
         * Run the migrations.
         */
        public function up(): void
        {
            Schema::create('booking_details', function (Blueprint $table) {
                $table->id();
                $table->foreignId('booking_id')->constrained()->onDelete('cascade');
                $table->foreignId('table_availability_id')->constrained()->onDelete('cascade');
                $table->integer('capacity');
                $table->boolean('extra_chair')->default(false);
                $table->timestamps();
            });
        }
    
        /**
         * Reverse the migrations.
         */
        public function down(): void
        {
            Schema::dropIfExists('booking_details');
        }
    };

––––––––––––––––––––––––
backend/database/migrations/2025_02_27_174815_create_jobs_table.php
    <?php
    
    use Illuminate\Database\Migrations\Migration;
    use Illuminate\Database\Schema\Blueprint;
    use Illuminate\Support\Facades\Schema;
    
    return new class extends Migration
    {
        /**
         * Run the migrations.
         */
        public function up(): void
        {
            Schema::create('jobs', function (Blueprint $table) {
                $table->bigIncrements('id');
                $table->string('queue')->index();
                $table->longText('payload');
                $table->unsignedTinyInteger('attempts');
                $table->unsignedInteger('reserved_at')->nullable();
                $table->unsignedInteger('available_at');
                $table->unsignedInteger('created_at');
            });
        }
    
        /**
         * Reverse the migrations.
         */
        public function down(): void
        {
            Schema::dropIfExists('jobs');
        }
    };

––––––––––––––––––––––––
backend/database/migrations/2025_04_20_143322_add_long_stay_to_bookings_table.php
    <?php
    
    use Illuminate\Database\Migrations\Migration;
    use Illuminate\Database\Schema\Blueprint;
    use Illuminate\Support\Facades\Schema;
    
    return new class extends Migration {
        public function up(): void
        {
            Schema::table('bookings', function (Blueprint $table) {
                $table->boolean('long_stay')->default(false)->after('marketing_opt_in');
            });
        }
    
        public function down(): void
        {
            Schema::table('bookings', function (Blueprint $table) {
                $table->dropColumn('long_stay');
            });
        }
    };

––––––––––––––––––––––––
backend/database/migrations/2025_05_04_155326_create_closed_days_table.php
    <?php
    
    use Illuminate\Database\Migrations\Migration;
    use Illuminate\Database\Schema\Blueprint;
    use Illuminate\Support\Facades\Schema;
    
    return new class extends Migration
    {
        public function up(): void
        {
            Schema::create('closed_days', function (Blueprint $table) {
                /* one row per date → PK */
                $table->date('date')->primary();
            });
        }
    
        public function down(): void
        {
            Schema::dropIfExists('closed_days');
        }
    };

––––––––––––––––––––––––
backend/database/migrations/2025_05_04_155330_create_system_settings_table.php
    <?php
    
    use Illuminate\Database\Migrations\Migration;
    use Illuminate\Database\Schema\Blueprint;
    use Illuminate\Support\Facades\Schema;
    
    return new class extends Migration
    {
        public function up(): void
        {
            Schema::create('system_settings', function (Blueprint $table) {
                $table->string('key')->primary();   // e.g. booking_open_from
                $table->string('value');
            });
        }
    
        public function down(): void
        {
            Schema::dropIfExists('system_settings');
        }
    };

––––––––––––––––––––––––
backend/database/migrations/2025_05_04_182837_create_calendar_overrides_table.php
    <?php
    
    use Illuminate\Database\Migrations\Migration;
    use Illuminate\Database\Schema\Blueprint;
    use Illuminate\Support\Facades\Schema;
    
    return new class extends Migration
    {
        /**
         * Create the table.
         */
        public function up(): void
        {
            Schema::create('calendar_overrides', function (Blueprint $table) {
                /* one row per date → PK */
                $table->date('date')->primary();
    
                /*
                 * 'open'  → force-open this date even if the weekly schedule says closed
                 * 'closed'→ force-close this date even if the weekly schedule says open
                 */
                $table->enum('state', ['open', 'closed']);
            });
        }
    
        /**
         * Drop the table.
         */
        public function down(): void
        {
            Schema::dropIfExists('calendar_overrides');
        }
    };

––––––––––––––––––––––––
backend/database/migrations/2025_05_04_184511_create_open_days_table.php
    <?php
    
    use Illuminate\Database\Migrations\Migration;
    use Illuminate\Database\Schema\Blueprint;
    use Illuminate\Support\Facades\Schema;
    
    return new class extends Migration
    {
        public function up(): void
        {
            Schema::create('open_days', function (Blueprint $table) {
                $table->date('date')->primary();        // YYYY-MM-DD
                $table->timestamps();
            });
        }
    
        public function down(): void
        {
            Schema::dropIfExists('open_days');
        }
    };

––––––––––––––––––––––––
backend/database/seeders/BookingSeeder.php
    <?php
    
    namespace Database\Seeders;
    
    use Illuminate\Database\Seeder;
    use App\Models\TableAvailability;
    use App\Models\Booking;
    use Faker\Factory as Faker;
    
    class BookingSeeder extends Seeder
    {
        public function run(): void
        {
            /* ─── read the toggle ─── */
            $demo = config('restaurant_dataset.demo_booking', []);
    
            if (empty($demo['enabled'])) {
                $this->command->info('Demo bookings disabled – skipping BookingSeeder.');
                return;
            }
    
            $faker           = Faker::create();
            $specialRequests = [
                'Window seat please',
                'Celebrating birthday',
                'High chair needed',
                'Vegetarian menu',
                'Allergic to nuts',
                'Anniversary celebration',
                'Quiet corner',
                'No special requests',
            ];
    
            // Pre-build time slots for each meal
            $slots = [
                'lunch'  => $this->buildSlots(13, 0, 16, 0),
                'dinner' => $this->buildSlots(20, 0, 22, 0),
            ];
    
            TableAvailability::chunkById(500, function ($chunk) use ($faker, $specialRequests, $slots) {
                foreach ($chunk as $stock) {
                    // Was floor($stock->available_count / 2); now use all tables
                    $maxToBook = $stock->available_count;
                    $count     = $maxToBook > 0 ? rand(0, $maxToBook) : 0;
    
                    for ($i = 0; $i < $count; $i++) {
                        Booking::create([
                            'table_availability_id' => $stock->id,
                            'total_adults'          => min($stock->capacity, rand(1, $stock->capacity)),
                            'total_kids'            => rand(0, 2),
                            'reserved_time'         => $faker->randomElement($slots[$stock->meal_type]),
                            'full_name'             => $faker->name,
                            'phone'                 => $faker->phoneNumber,
                            'email'                 => $faker->safeEmail,
                            'special_requests'      => $faker->randomElement($specialRequests),
                            'gdpr_consent'          => true,
                            'marketing_opt_in'      => $faker->boolean(30),
                            'long_stay'             => $faker->boolean(10),
                        ]);
                    }
                }
            });
    
            $this->command->info('✅ Demo bookings generated.');
        }
    
        /** Generate HH:MM:00 slots every 15 minutes */
        private function buildSlots(int $fromH, int $fromM, int $toH, int $toM): array
        {
            $out = [];
            for ($h = $fromH, $m = $fromM;
                 ($h < $toH) || ($h === $toH && $m <= $toM);
                 ($m += 15) >= 60 && ($h += 1) && ($m = 0)
            ) {
                $out[] = sprintf('%02d:%02d:00', $h, $m);
            }
            return $out;
        }
    }

––––––––––––––––––––––––
backend/database/seeders/DatabaseSeeder.php
    <?php
    
    namespace Database\Seeders;
    
    use Illuminate\Database\Seeder;
    
    class DatabaseSeeder extends Seeder
    {
        /**
         * Seed the application's database.
         */
        public function run(): void
        {
            $this->call([
                TableAvailabilitySeeder::class,
                BookingSeeder::class,           // heavier random bookings now
                ReallocateBookingsSeeder::class // then re-seat them for minimal waste
            ]);
        }
    }

––––––––––––––––––––––––
backend/database/seeders/TableAvailabilitySeeder.php
    <?php
    
    namespace Database\Seeders;
    
    use Illuminate\Database\Seeder;
    use App\Models\TableAvailability;
    use Carbon\Carbon;
    use Illuminate\Support\Facades\Config;
    
    class TableAvailabilitySeeder extends Seeder
    {
        public function run(): void
        {
            /* ─── read dataset ─── */
            // ⬇️ drop the 'important.' prefix
            $ds = Config::get('restaurant_dataset', []);
    
            $horizonDays     = $ds['seeding_horizon_days'] ?? 30;
            $tableTypes      = $ds['table_types']          ?? [];
            $serviceSchedule = $ds['service_schedule']     ?? [];
    
            /* ─── fallback ─── */
            if (empty($tableTypes)) {
                $tableTypes = [
                    ['capacity' => 2, 'available_count' => 4],
                    ['capacity' => 4, 'available_count' => 7],
                    ['capacity' => 6, 'available_count' => 7],
                ];
            }
    
            $start = Carbon::today();
            $end   = Carbon::today()->addDays($horizonDays - 1);
    
            for ($d = $start->copy(); $d->lte($end); $d->addDay()) {
                $dow       = $d->dayOfWeek;               // 0 = Sun … 6 = Sat
                $mealTypes = $serviceSchedule[$dow] ?? [];
    
                if (empty($mealTypes)) {
                    continue;                            // closed
                }
    
                foreach ($mealTypes as $meal) {
                    foreach ($tableTypes as $t) {
                        TableAvailability::create([
                            'date'            => $d->toDateString(),
                            'meal_type'       => $meal,
                            'capacity'        => $t['capacity'],
                            'available_count' => $t['available_count'],
                        ]);
                    }
                }
            }
    
            $this->command->info('✅ Table availability stock generated.');
        }
    }

––––––––––––––––––––––––
backend/routes/api.php
    <?php
    
    use Illuminate\Http\Request;
    use Illuminate\Support\Facades\Route;
    use App\Http\Controllers\{
        BookingController,
        TableAvailabilityController,
        ClosedDayController,
        OpenDayController,
        SystemSettingController,
        MealOverrideController,             // ← NEW
        MetaController
    };
    
    Route::get('/', fn () => response()->json(['message' => 'API root']));
    Route::middleware('auth:sanctum')->get('/user', fn (Request $r) => $r->user());
    
    /* Availability */
    Route::get('/table-availability',       [TableAvailabilityController::class,'index']);
    Route::get('/table-availability-range', [TableAvailabilityController::class,'range']);
    
    /* Bookings CRUD */
    Route::get   ('/bookings',           [BookingController::class,'index']);
    Route::post  ('/bookings',           [BookingController::class,'store']);
    Route::patch ('/bookings/{booking}', [BookingController::class,'update']);
    Route::delete('/bookings/{booking}',  [BookingController::class,'destroy']);
    
    /* Calendar overrides & settings */
    Route::get ('/closed-days',        [ClosedDayController::class,'index']);
    Route::post('/closed-days/toggle', [ClosedDayController::class,'toggle']);
    Route::get ('/open-days',          [OpenDayController::class,'index']);
    Route::post('/open-days/toggle',   [OpenDayController::class,'toggle']);
    
    /* NEW meal-overrides */
    Route::get ('/meal-overrides',         [MealOverrideController::class,'index']);
    Route::post('/meal-overrides/toggle',  [MealOverrideController::class,'toggle']);
    
    Route::get ('/settings/booking-open-from', [SystemSettingController::class,'show']);
    Route::put ('/settings/booking-open-from', [SystemSettingController::class,'update']);
    
    /* ─── Meta helpers consumed by the SPA ────────────────────────────── */
    Route::get('/meta/horizon-days',     [MetaController::class,'horizonDays']);
    Route::get('/meta/service-schedule', [MetaController::class,'serviceSchedule']);

––––––––––––––––––––––––
backend/config/mail.php
    <?php
    
    return [
    
        /*
        |--------------------------------------------------------------------------
        | Default Mailer
        |--------------------------------------------------------------------------
        |
        | This option controls the default mailer that is used to send any email
        | messages sent by your application. Alternative mailers may be setup
        | and used as needed; however, this mailer will be used by default.
        |
        */
    
        'default' => env('MAIL_MAILER', 'smtp'),
    
        /*
        |--------------------------------------------------------------------------
        | Mailer Configurations
        |--------------------------------------------------------------------------
        |
        | Here you may configure all of the mailers used by your application plus
        | their respective settings. Several examples have been configured for
        | you and you are free to add your own as your application requires.
        |
        | Laravel supports a variety of mail "transport" drivers to be used while
        | sending an e-mail. You will specify which one you are using for your
        | mailers below. You are free to add additional mailers as required.
        |
        | Supported: "smtp", "sendmail", "mailgun", "ses", "ses-v2",
        |            "postmark", "log", "array", "failover", "roundrobin"
        |
        */
    
        'mailers' => [
            'smtp' => [
                'transport' => 'smtp',
                'url' => env('MAIL_URL'),
                'host' => env('MAIL_HOST', 'smtp.mailgun.org'),
                'port' => env('MAIL_PORT', 587),
                'encryption' => env('MAIL_ENCRYPTION', 'tls'),
                'username' => env('MAIL_USERNAME'),
                'password' => env('MAIL_PASSWORD'),
                'timeout' => null,
                'local_domain' => env('MAIL_EHLO_DOMAIN'),
            ],
    
            'ses' => [
                'transport' => 'ses',
            ],
    
            'postmark' => [
                'transport' => 'postmark',
                // 'message_stream_id' => null,
                // 'client' => [
                //     'timeout' => 5,
                // ],
            ],
    
            'mailgun' => [
                'transport' => 'mailgun',
                // 'client' => [
                //     'timeout' => 5,
                // ],
            ],
    
            'sendmail' => [
                'transport' => 'sendmail',
                'path' => env('MAIL_SENDMAIL_PATH', '/usr/sbin/sendmail -bs -i'),
            ],
    
            'log' => [
                'transport' => 'log',
                'channel' => env('MAIL_LOG_CHANNEL'),
            ],
    
            'array' => [
                'transport' => 'array',
            ],
    
            'failover' => [
                'transport' => 'failover',
                'mailers' => [
                    'smtp',
                    'log',
                ],
            ],
    
            'roundrobin' => [
                'transport' => 'roundrobin',
                'mailers' => [
                    'ses',
                    'postmark',
                ],
            ],
        ],
    
        /*
        |--------------------------------------------------------------------------
        | Global "From" Address
        |--------------------------------------------------------------------------
        |
        | You may wish for all e-mails sent by your application to be sent from
        | the same address. Here, you may specify a name and address that is
        | used globally for all e-mails that are sent by your application.
        |
        */
    
        'from' => [
            'address' => env('MAIL_FROM_ADDRESS', 'hello@example.com'),
            'name' => env('MAIL_FROM_NAME', 'Example'),
        ],
    
        /*
        |--------------------------------------------------------------------------
        | Markdown Mail Settings
        |--------------------------------------------------------------------------
        |
        | If you are using Markdown based email rendering, you may configure your
        | theme and component paths here, allowing you to customize the design
        | of the emails. Or, you may simply stick with the Laravel defaults!
        |
        */
    
        'markdown' => [
            'theme' => 'default',
    
            'paths' => [
                resource_path('views/vendor/mail'),
            ],
        ],
    
    ];

––––––––––––––––––––––––
backend/config/restaurant.php
    <?php
    /**
     * Restaurant-level operational parameters
     * (single source of truth for the algorithm).
     *
     */
    
    return [
    
        /*───────────────────────────────────────────────────────────
         | Seating rounds – start / end for every service window
         *───────────────────────────────────────────────────────────*/
        'rounds' => [
            'lunch' => [
                'first_round'  => [
                    'start' => '13:00',
                    'end'   => '14:59',
                    'note'  => '1st lunch',
                ],
                'second_round' => [
                    'start' => '15:00',
                    'end'   => '17:30',
                    'note'  => '2nd lunch',
                ],
            ],
            'dinner' => [
                'dinner_round' => [
                    'start' => '20:00',
                    'end'   => '23:30',
                    'note'  => 'Dinner',
                ],
            ],
        ],
    
        /*───────────────────────────────────────────────────────────
         | Party-size slack ϵ   ( capacity ≥ party − ϵ )
         *───────────────────────────────────────────────────────────*/
        'party_to_eps' => [
            1 => 0,
            2 => 3,
            3 => 2,
            4 => 1,
        ],
    
        /*───────────────────────────────────────────────────────────
         | Slot granularity – minutes between successive booking slots
         *───────────────────────────────────────────────────────────*/
        'slot_step'    => 15,
    
        /*───────────────────────────────────────────────────────────
         | Physical table sizes available
         *───────────────────────────────────────────────────────────*/
        'capacities'   => [2, 4, 6],
    
        /*───────────────────────────────────────────────────────────
         | ZONE THRESHOLDS φ1..φ4 (five-zone policy)
         | Hard-coded values; widget will never re-derive these.
         *───────────────────────────────────────────────────────────*/
        'phi' => [
            'phi1' => 0.401,
            'phi2' => 0.547,
            'phi3' => 0.714,
            'phi4' => 0.800,
        ],
    
        /*───────────────────────────────────────────────────────────
         | Session parameters
         *───────────────────────────────────────────────────────────*/
        'tau'           => 1.75,    // hours incl. cleaning
        'omega'         => 1.50,    // long-stay multiplier
        'p_max'         => 14,      // largest party bookable online
        'beta'          => 0.05,    // walk-in buffer 5%
        'eta_max'       => 0.10,    // total invisible seats ≤10%
        'rebuild_times' => ['11:00', '17:00'], // daily shuffle
    ];

––––––––––––––––––––––––
backend/config/restaurant_dataset.php
    <?php
    /**
     * Operational dataset used by seeders and runtime code.
     * Edit this file to adapt the software to a new venue – no code changes required.
     */
    
    return [
    
        /*
        |--------------------------------------------------------------------------
        | How far ahead to pre-generate stock (in days)
        |--------------------------------------------------------------------------
        */
        'seeding_horizon_days' => 90,   // ← updated from 30 → 90
    
        /*
        |--------------------------------------------------------------------------
        | Table mix
        |--------------------------------------------------------------------------
        | One entry per table size you own:
        |   capacity  → seats per table
        |   available_count → how many such tables exist
        */
        'table_types' => [
            ['capacity' => 2, 'available_count' => 4],
            ['capacity' => 4, 'available_count' => 7],
            ['capacity' => 6, 'available_count' => 7],
        ],
    
        /*
        |--------------------------------------------------------------------------
        | Weekly service schedule
        |--------------------------------------------------------------------------
        | Keys are Carbon day-of-week integers (0 = Sun … 6 = Sat).
        | Value is an array of meal types served that day.
        | Empty array ⇒ restaurant closed.
        */
        'service_schedule' => [
            0 => ['lunch', 'dinner'], // Sunday
            1 => [],                  // Monday    (closed)
            2 => [],                  // Tuesday   (closed)
            3 => ['lunch'],           // Wednesday
            4 => ['lunch'],           // Thursday
            5 => ['lunch', 'dinner'], // Friday
            6 => ['lunch', 'dinner'], // Saturday
        ],
    
        /*
        |--------------------------------------------------------------------------
        | Default slot used by the demo-booking seeder
        |--------------------------------------------------------------------------
        */
        'default_reserved_time' => '12:30:00',
    
        /*
        |--------------------------------------------------------------------------
        | Demo booking (turn off in production)
        |--------------------------------------------------------------------------
        */
        'demo_booking' => [
            'enabled'          => true,
            'full_name'        => 'Test User',
            'phone'            => '+34 600000000',
            'email'            => 'test@example.com',
            'special_requests' => 'No special requests',
            'gdpr_consent'     => true,
            'marketing_opt_in' => false,
        ],
    ];

